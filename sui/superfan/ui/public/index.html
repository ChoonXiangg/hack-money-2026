<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Superfan - Fan Badge Tester</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      min-height: 100vh;
      color: #fff;
      padding: 20px;
    }
    .container { max-width: 800px; margin: 0 auto; }
    h1 {
      text-align: center;
      margin-bottom: 10px;
      font-size: 2.5rem;
      background: linear-gradient(90deg, #00d4ff, #7b2cbf);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    .subtitle { text-align: center; color: #888; margin-bottom: 30px; }
    .card {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 16px;
      padding: 24px;
      margin-bottom: 20px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    .card h2 { margin-bottom: 16px; font-size: 1.2rem; color: #00d4ff; }
    .badge-display {
      display: flex;
      align-items: center;
      gap: 20px;
      padding: 20px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 12px;
    }
    .badge-icon {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2rem;
    }
    .badge-icon.bronze { background: linear-gradient(135deg, #cd7f32, #8b4513); }
    .badge-icon.silver { background: linear-gradient(135deg, #c0c0c0, #808080); }
    .badge-icon.gold { background: linear-gradient(135deg, #ffd700, #ff8c00); }
    .badge-info h3 { font-size: 1.5rem; margin-bottom: 8px; }
    .badge-info p { color: #aaa; margin-bottom: 4px; }
    .stats { display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; margin-top: 16px; }
    .stat { background: rgba(0, 212, 255, 0.1); padding: 12px; border-radius: 8px; text-align: center; }
    .stat-value { font-size: 1.5rem; font-weight: bold; color: #00d4ff; }
    .stat-label { font-size: 0.8rem; color: #888; }
    .form-group { margin-bottom: 16px; }
    label { display: block; margin-bottom: 8px; color: #aaa; }
    input, select {
      width: 100%;
      padding: 12px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      background: rgba(0, 0, 0, 0.3);
      color: #fff;
      font-size: 1rem;
    }
    input:focus, select:focus { outline: none; border-color: #00d4ff; }
    button {
      padding: 12px 24px;
      border-radius: 8px;
      border: none;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.2s;
      margin-right: 8px;
      margin-bottom: 8px;
    }
    .btn-primary { background: linear-gradient(90deg, #00d4ff, #7b2cbf); color: #fff; }
    .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 4px 20px rgba(0, 212, 255, 0.3); }
    .btn-secondary { background: rgba(255, 255, 255, 0.1); color: #fff; }
    .btn-secondary:hover { background: rgba(255, 255, 255, 0.2); }
    .btn-connect { background: linear-gradient(90deg, #4158d0, #c850c0); color: #fff; width: 100%; padding: 16px; font-size: 1.1rem; }
    .status { padding: 12px; border-radius: 8px; margin-top: 16px; font-family: monospace; font-size: 0.9rem; max-height: 200px; overflow-y: auto; white-space: pre-wrap; }
    .status.success { background: rgba(0, 255, 0, 0.1); border: 1px solid rgba(0, 255, 0, 0.3); }
    .status.error { background: rgba(255, 0, 0, 0.1); border: 1px solid rgba(255, 0, 0, 0.3); }
    .status.info { background: rgba(0, 212, 255, 0.1); border: 1px solid rgba(0, 212, 255, 0.3); }
    .connected { display: flex; align-items: center; gap: 10px; padding: 12px; background: rgba(0, 255, 0, 0.1); border-radius: 8px; margin-bottom: 16px; }
    .connected .dot { width: 10px; height: 10px; background: #00ff00; border-radius: 50%; }
    .address { font-family: monospace; color: #00d4ff; word-break: break-all; }
    .hidden { display: none; }
    .quick-actions { display: flex; flex-wrap: wrap; gap: 8px; }
    .tier-progress { margin-top: 16px; background: rgba(0, 0, 0, 0.3); border-radius: 8px; padding: 16px; }
    .progress-bar { height: 8px; background: rgba(255, 255, 255, 0.1); border-radius: 4px; overflow: hidden; margin: 8px 0; }
    .progress-fill { height: 100%; background: linear-gradient(90deg, #00d4ff, #7b2cbf); transition: width 0.3s; }
    .progress-labels { display: flex; justify-content: space-between; font-size: 0.8rem; color: #888; }
    .wallet-list { display: flex; flex-direction: column; gap: 8px; }
    .wallet-btn { background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); padding: 12px 16px; border-radius: 8px; color: #fff; cursor: pointer; display: flex; align-items: center; gap: 12px; transition: all 0.2s; width: 100%; }
    .wallet-btn:hover { background: rgba(255, 255, 255, 0.2); border-color: #00d4ff; }
    .wallet-btn img { width: 28px; height: 28px; border-radius: 6px; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Superfan</h1>
    <p class="subtitle">Fan Badge System on Sui Testnet</p>

    <!-- Wallet Connection -->
    <div class="card" id="wallet-section">
      <h2>Wallet Connection</h2>
      <div id="not-connected">
        <p style="margin-bottom: 16px; color: #888;">Select a wallet to connect:</p>
        <div class="wallet-list" id="wallet-list">
          <p style="color: #666;">Loading wallets...</p>
        </div>
      </div>
      <div id="connected" class="hidden">
        <div class="connected">
          <span class="dot"></span>
          <span id="wallet-name">Connected</span>
        </div>
        <p class="address" id="wallet-address"></p>
        <button class="btn-secondary" onclick="disconnectWallet()" style="margin-top: 12px;">Disconnect</button>
      </div>
    </div>

    <!-- Badge Display -->
    <div class="card" id="badge-section">
      <h2>Your Fan Badge</h2>
      <div id="no-badge">
        <p style="color: #888; margin-bottom: 16px;">You don't have a badge yet. Mint one to get started!</p>
        <div class="form-group">
          <label>Artist Address</label>
          <input type="text" id="artist-address" placeholder="0x..." value="0x467c14656b9da39218a4dd756d782d159bc6dbf59b219980e19ffd45d5145f2f">
        </div>
        <button class="btn-primary" onclick="mintBadge()">Mint Badge</button>
      </div>
      <div id="has-badge" class="hidden">
        <div class="badge-display">
          <div class="badge-icon" id="badge-icon">ðŸŽµ</div>
          <div class="badge-info">
            <h3 id="tier-name">Bronze Fan</h3>
            <p>Artist: <span id="badge-artist" class="address"></span></p>
            <p>Badge ID: <span id="badge-id" class="address"></span></p>
          </div>
        </div>
        <div class="stats">
          <div class="stat">
            <div class="stat-value" id="listen-seconds">0</div>
            <div class="stat-label">Listen Seconds</div>
          </div>
          <div class="stat">
            <div class="stat-value" id="listen-time">0:00</div>
            <div class="stat-label">Total Time</div>
          </div>
        </div>
        <div class="tier-progress">
          <div style="display: flex; justify-content: space-between;">
            <span>Progress to next tier</span>
            <span id="progress-text">0%</span>
          </div>
          <div class="progress-bar">
            <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
          </div>
          <div class="progress-labels">
            <span>Bronze</span>
            <span>Silver (1hr)</span>
            <span>Gold (10hr)</span>
          </div>
        </div>
      </div>
    </div>

    <!-- Actions -->
    <div class="card" id="actions-section">
      <h2>Actions</h2>
      <div class="form-group">
        <label>Badge Object ID</label>
        <input type="text" id="badge-object-id" placeholder="0x..." value="0xaf00964bc3a888295029ac32e04f314db71a4f3cb634ed0c283f886bd9085ce8">
      </div>
      <div class="form-group">
        <label>Seconds to Add</label>
        <input type="number" id="seconds-input" value="60" min="1">
      </div>
      <div class="quick-actions">
        <button class="btn-secondary" onclick="addTime(60)">+1 min</button>
        <button class="btn-secondary" onclick="addTime(300)">+5 min</button>
        <button class="btn-secondary" onclick="addTime(600)">+10 min</button>
        <button class="btn-secondary" onclick="addTime(3600)">+1 hour</button>
      </div>
      <div style="margin-top: 16px;">
        <button class="btn-primary" onclick="addListenTime()">Add Listen Time</button>
        <button class="btn-primary" onclick="updateTier()">Update Tier</button>
        <button class="btn-secondary" onclick="refreshBadge()">Refresh Badge</button>
      </div>
      <div id="status" class="status info hidden"></div>
    </div>

    <!-- Contract Info -->
    <div class="card">
      <h2>Contract Info</h2>
      <p style="color: #888; margin-bottom: 8px;">Network: <span style="color: #00d4ff;">Testnet</span></p>
      <p style="color: #888; margin-bottom: 8px;">Package ID:</p>
      <p class="address" style="font-size: 0.85rem;">0x8b8cb9a484cde96919ee9104c63e94fa5d453a678fd306a7615aa16014ccd6a2</p>
    </div>
  </div>

  <script>
    const PACKAGE_ID = '0x8b8cb9a484cde96919ee9104c63e94fa5d453a678fd306a7615aa16014ccd6a2';
    const MODULE = 'badge';
    const RPC_URL = 'https://fullnode.testnet.sui.io:443';

    let walletAddress = null;
    let currentBadge = null;
    let connectedWallet = null;
    let connectedAccount = null;
    let availableWallets = [];

    // Get the wallet-standard registry (created by wallets, not by us)
    function getWalletsApi() {
      return window[Symbol.for('wallet-standard:wallets')] || null;
    }

    function getRegisteredWallets() {
      const api = getWalletsApi();
      if (!api) {
        console.log('Wallet standard API not found yet');
        return [];
      }

      const wallets = api.get ? api.get() : [];

      // Listen for new wallets
      if (api.on) {
        api.on('register', (wallet) => {
          console.log('New wallet registered:', wallet.name);
          if (!availableWallets.find(w => w.name === wallet.name)) {
            availableWallets.push(wallet);
            renderWalletList();
          }
        });
      }

      // Filter for Sui-compatible wallets
      return wallets.filter(w =>
        w.chains?.some(chain => chain.startsWith('sui:'))
      );
    }

    function renderWalletList() {
      const listEl = document.getElementById('wallet-list');

      if (availableWallets.length === 0) {
        listEl.innerHTML = `
          <p style="color: #888; margin-bottom: 12px;">No Sui wallets detected.</p>
          <a href="https://slush.app" target="_blank" class="wallet-btn" style="text-decoration: none; justify-content: center;">
            Install Slush Wallet
          </a>
        `;
        return;
      }

      listEl.innerHTML = availableWallets.map((wallet, index) => `
        <button class="wallet-btn" onclick="connectToWallet(${index})">
          ${wallet.icon ? `<img src="${wallet.icon}" alt="${wallet.name}">` : ''}
          <span>${wallet.name}</span>
        </button>
      `).join('');
    }

    async function connectToWallet(index) {
      const wallet = availableWallets[index];
      if (!wallet) {
        showStatus('Wallet not found', 'error');
        return;
      }

      showStatus(`Connecting to ${wallet.name}...`, 'info');

      try {
        // Use the standard:connect feature - this triggers the popup!
        const connectFeature = wallet.features['standard:connect'];
        if (!connectFeature) {
          throw new Error('Wallet does not support connect feature');
        }

        const { accounts } = await connectFeature.connect();

        if (!accounts || accounts.length === 0) {
          throw new Error('No accounts returned');
        }

        connectedWallet = wallet;
        connectedAccount = accounts[0];
        walletAddress = connectedAccount.address;

        document.getElementById('not-connected').classList.add('hidden');
        document.getElementById('connected').classList.remove('hidden');
        document.getElementById('wallet-address').textContent = walletAddress;
        document.getElementById('wallet-name').textContent = `Connected via ${wallet.name}`;

        showStatus('Connected: ' + walletAddress.slice(0, 10) + '...', 'success');
        await findUserBadge();
      } catch (error) {
        console.error('Connect error:', error);
        showStatus('Connection failed: ' + error.message, 'error');
      }
    }

    function disconnectWallet() {
      if (connectedWallet?.features?.['standard:disconnect']) {
        connectedWallet.features['standard:disconnect'].disconnect();
      }
      walletAddress = null;
      currentBadge = null;
      connectedWallet = null;
      connectedAccount = null;
      document.getElementById('not-connected').classList.remove('hidden');
      document.getElementById('connected').classList.add('hidden');
      document.getElementById('has-badge').classList.add('hidden');
      document.getElementById('no-badge').classList.remove('hidden');
      showStatus('Wallet disconnected', 'info');
    }

    async function rpcCall(method, params) {
      const response = await fetch(RPC_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ jsonrpc: '2.0', id: 1, method, params })
      });
      const data = await response.json();
      if (data.error) throw new Error(data.error.message);
      return data.result;
    }

    async function findUserBadge() {
      if (!walletAddress) return;

      showStatus('Searching for your badges...', 'info');

      try {
        const result = await rpcCall('suix_getOwnedObjects', [
          walletAddress,
          { filter: { StructType: `${PACKAGE_ID}::${MODULE}::FanBadge` }, options: { showContent: true } }
        ]);

        if (result.data && result.data.length > 0) {
          const badge = result.data[0];
          const fields = badge.data.content.fields;
          currentBadge = {
            id: badge.data.objectId,
            artistId: fields.artist_id,
            fan: fields.fan,
            listenSeconds: parseInt(fields.listen_seconds),
            tier: parseInt(fields.tier)
          };

          document.getElementById('badge-object-id').value = currentBadge.id;
          updateBadgeDisplay();
          showStatus('Found your badge!', 'success');
        } else {
          showStatus('No badge found for this wallet. You can mint one!', 'info');
        }
      } catch (error) {
        showStatus('Error finding badge: ' + error.message, 'error');
      }
    }

    function updateBadgeDisplay() {
      if (!currentBadge) return;

      document.getElementById('no-badge').classList.add('hidden');
      document.getElementById('has-badge').classList.remove('hidden');

      const tierNames = ['', 'Bronze', 'Silver', 'Gold'];
      const tierClasses = ['', 'bronze', 'silver', 'gold'];

      document.getElementById('tier-name').textContent = tierNames[currentBadge.tier] + ' Fan';
      document.getElementById('badge-icon').className = 'badge-icon ' + tierClasses[currentBadge.tier];
      document.getElementById('badge-artist').textContent = currentBadge.artistId.slice(0, 10) + '...' + currentBadge.artistId.slice(-8);
      document.getElementById('badge-id').textContent = currentBadge.id.slice(0, 10) + '...' + currentBadge.id.slice(-8);
      document.getElementById('listen-seconds').textContent = currentBadge.listenSeconds.toLocaleString();

      const hours = Math.floor(currentBadge.listenSeconds / 3600);
      const mins = Math.floor((currentBadge.listenSeconds % 3600) / 60);
      const secs = currentBadge.listenSeconds % 60;
      document.getElementById('listen-time').textContent =
        hours > 0 ? `${hours}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`
                  : `${mins}:${secs.toString().padStart(2, '0')}`;

      let progress = 0, progressText = '';
      if (currentBadge.tier === 1) {
        progress = Math.min(100, (currentBadge.listenSeconds / 3600) * 100);
        progressText = `${Math.round(progress)}% to Silver`;
      } else if (currentBadge.tier === 2) {
        progress = Math.min(100, (currentBadge.listenSeconds / 36000) * 100);
        progressText = `${Math.round(progress)}% to Gold`;
      } else {
        progress = 100;
        progressText = 'Max tier reached!';
      }
      document.getElementById('progress-fill').style.width = progress + '%';
      document.getElementById('progress-text').textContent = progressText;
    }

    async function signAndExecuteTransaction(txBytes) {
      if (!connectedWallet || !connectedAccount) {
        throw new Error('No wallet connected');
      }

      // Try sui:signAndExecuteTransactionBlock (newer API)
      let signFeature = connectedWallet.features['sui:signAndExecuteTransactionBlock'];
      if (signFeature) {
        return await signFeature.signAndExecuteTransactionBlock({
          transactionBlock: txBytes,
          account: connectedAccount,
          chain: 'sui:testnet'
        });
      }

      // Try sui:signAndExecuteTransaction (even newer API)
      signFeature = connectedWallet.features['sui:signAndExecuteTransaction'];
      if (signFeature) {
        return await signFeature.signAndExecuteTransaction({
          transaction: txBytes,
          account: connectedAccount,
          chain: 'sui:testnet'
        });
      }

      throw new Error('Wallet does not support transaction signing');
    }

    async function buildAndExecute(func, args) {
      // Build transaction using unsafe_moveCall
      const txResponse = await rpcCall('unsafe_moveCall', [
        walletAddress,
        PACKAGE_ID,
        MODULE,
        func,
        [], // type args
        args,
        null, // gas object
        '10000000' // gas budget
      ]);

      return await signAndExecuteTransaction(txResponse.txBytes);
    }

    async function mintBadge() {
      if (!walletAddress) {
        showStatus('Please connect your wallet first', 'error');
        return;
      }

      const artistAddress = document.getElementById('artist-address').value;
      if (!artistAddress) {
        showStatus('Please enter an artist address', 'error');
        return;
      }

      showStatus('Minting badge... Please approve in wallet', 'info');

      try {
        const result = await buildAndExecute('mint_badge', [artistAddress]);
        showStatus('Badge minted!\nTX: ' + (result?.digest || 'Success'), 'success');
        setTimeout(findUserBadge, 2000);
      } catch (error) {
        console.error('Mint error:', error);
        showStatus('Mint failed: ' + error.message, 'error');
      }
    }

    function addTime(seconds) {
      document.getElementById('seconds-input').value = seconds;
    }

    async function addListenTime() {
      if (!walletAddress) {
        showStatus('Please connect your wallet first', 'error');
        return;
      }

      const badgeId = document.getElementById('badge-object-id').value;
      const seconds = parseInt(document.getElementById('seconds-input').value);

      if (!badgeId) {
        showStatus('Please enter a badge object ID', 'error');
        return;
      }

      showStatus('Adding listen time... Please approve in wallet', 'info');

      try {
        const result = await buildAndExecute('add_listen_time', [badgeId, seconds.toString()]);
        showStatus('Added ' + seconds + ' seconds!\nTX: ' + (result?.digest || 'Success'), 'success');
        setTimeout(refreshBadge, 2000);
      } catch (error) {
        console.error('Add time error:', error);
        showStatus('Failed: ' + error.message, 'error');
      }
    }

    async function updateTier() {
      if (!walletAddress) {
        showStatus('Please connect your wallet first', 'error');
        return;
      }

      const badgeId = document.getElementById('badge-object-id').value;
      if (!badgeId) {
        showStatus('Please enter a badge object ID', 'error');
        return;
      }

      showStatus('Updating tier... Please approve in wallet', 'info');

      try {
        const result = await buildAndExecute('update_tier', [badgeId]);
        showStatus('Tier updated!\nTX: ' + (result?.digest || 'Success'), 'success');
        setTimeout(refreshBadge, 2000);
      } catch (error) {
        console.error('Update tier error:', error);
        showStatus('Failed: ' + error.message, 'error');
      }
    }

    async function refreshBadge() {
      const badgeId = document.getElementById('badge-object-id').value;
      if (!badgeId) {
        if (walletAddress) await findUserBadge();
        return;
      }

      showStatus('Refreshing badge...', 'info');

      try {
        const result = await rpcCall('sui_getObject', [badgeId, { showContent: true }]);

        if (result.data && result.data.content) {
          const fields = result.data.content.fields;
          currentBadge = {
            id: badgeId,
            artistId: fields.artist_id,
            fan: fields.fan,
            listenSeconds: parseInt(fields.listen_seconds),
            tier: parseInt(fields.tier)
          };
          updateBadgeDisplay();
          showStatus('Badge refreshed!', 'success');
        }
      } catch (error) {
        showStatus('Error: ' + error.message, 'error');
      }
    }

    function showStatus(message, type) {
      const status = document.getElementById('status');
      status.textContent = message;
      status.className = 'status ' + type;
      status.classList.remove('hidden');
    }

    // Debug: check what's available in window
    function debugWalletGlobals() {
      console.log('=== Wallet Debug ===');
      const api = window[Symbol.for('wallet-standard:wallets')];
      console.log('Wallet Standard API:', api);
      if (api && api.get) {
        const wallets = api.get();
        console.log('Registered wallets from API:', wallets);
        wallets.forEach((w, i) => {
          console.log(`Wallet ${i}:`, w.name, w.chains, w.features ? Object.keys(w.features) : 'no features');
        });
      }
    }

    // Initialize on page load
    function initWallets() {
      debugWalletGlobals();
      availableWallets = getRegisteredWallets();
      console.log('Found wallets:', availableWallets.map(w => w.name));
      console.log('Wallet details:', availableWallets);
      renderWalletList();
    }

    window.addEventListener('load', () => {
      // Load badge data immediately
      refreshBadge();

      // Give wallets time to inject and register
      // Slush and other wallets need time to initialize
      setTimeout(initWallets, 100);
      setTimeout(initWallets, 500);
      setTimeout(initWallets, 1000);
      setTimeout(initWallets, 2000);
      setTimeout(initWallets, 3000);
    });
  </script>
</body>
</html>
